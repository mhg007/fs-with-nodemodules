const { URL, URLSearchParams } = require('url');
const { assign, createMachine, sendParent } = require("xstate");
const { getLogger } = require("./logging.js");
const { getToken } = require("./auth.js");
const FormData = require("form-data");
const { tokenMapper } = require("@teresol-v2/token-mapper");
const fetch = (url, options) => import("node-fetch").then(({ default: fetch }) => fetch(url, options));

const logger = getLogger("FetchMachine.js");

class ServiceError extends Error {
    constructor(message, httpStatus, errorResponse) {
        super(message);
        this.httpStatus = httpStatus;
        this.errorResponse = errorResponse;
    }
}

const FetchActor = createMachine(
    {
        id: "FETCH",
        predictableActionArguments: true,
        initial: "Idle",
        context: {
            url: "",
            request: "",
            parameter: "",
            success: "",
            failure: "",
            response: "ok",
            message: "error",
            errorMessage: "",
            mBoolean: false,
            header: {},
            result: {},
            emptyHeader: {},
        },
        states: {
            Idle: {
                on: {
                    FETCH: {
                        target: "GetData",
                        actions: ["receiveEvent"]
                    },
                },
            },
            GetData: {
                invoke: {
                    id: "GetData",
                    src: "getData",
                    onDone: {
                        target: "Final",
                        actions: [
                            assign({
                                result: (context, event) => {
                                    return event.data.data;
                                },
                                httpResponseHeader: (context, event) => {
                                    return event.data.httpResponseHeader;
                                },
                                httpStatus: (context, event) => {
                                    return event.data.httpStatus;
                                }
                            }),
                            sendParent((context, _event) => ({
                                ...context,
                                type: context.success,
                            }))
                        ],
                    },
                    onError: {
                        target: "Final",
                        actions: [
                            assign({
                                mBoolean: true,
                                errorMessage: (context, event) => {
                                    return event.data.message;
                                },
                                errorResponse: (context, event) => {
                                    return event.data.errorResponse;
                                },
                                httpStatus: (context, event) => {
                                    return event.data.httpStatus;
                                }
                            }),
                            sendParent((context, _event) => ({
                                ...context,
                                type: context.failure,
                            }))
                        ],
                    },
                },
            },
            Final: {
                type: "final",
            }
        }
    },
    {
        services: {
            getData: async (context, _event) => {
                const method = context.request;
                const headers = JSON.stringify(context.header) == JSON.stringify(context.emptyHeader) ? { "Content-Type": "application/json" } : context.header;
                const contentType = context.header["Content-Type"];
                const options = { headers, method };
                const httpResponseHeader = {};
                let httpStatus = null;
                if (context.request === "GET" || context.request === "DELETE") {
                    const url = new URL(context.url);
                    const queryParams = new URLSearchParams(url.search);
                    logger.info(`${context.logPrefix} ${context.request} ${url.hostname}${url.pathname}`);
                    logger.debug(`${context.logPrefix} Parameters: ${queryParams}`);
                }
                else {
                    logger.info(`${context.logPrefix} ${context.request} ${context.url}`);
                    if (contentType.includes("multipart/form-data")) {
                        logger.debug(`${context.logPrefix} Parameters: Received Multipart Form Data`);
                    }
                    else {
                        logger.debug(`${context.logPrefix} Parameters: ${JSON.stringify(context.parameter)}`);
                    }
                }
                if (method === "POST" || method === "PUT") {
                    if (contentType.includes("multipart/form-data")) {
                        let formData = new FormData();
                        Object.keys(context.parameter).forEach((key) => {
                            if (key == "files" && Array.isArray(context.parameter.files)) {
                                for (let file of context.parameter.files) {
                                    formData.append(file.field, file.data, {
                                        contentType: file.mimeType,
                                        filename: file.filename,
                                        encoding: file.encoding
                                    })
                                }
                            }
                            else {
                                formData.append(key, context.parameter[key]);
                            }
                        });
                        options.body = formData;
                        delete options.headers["Content-Type"];
                    }
                    else {
                        options.body = JSON.stringify(context.parameter);
                    }
                }
                return await fetch(context.url, options)
                    .then((response) => {
                        logger.info(`${context.logPrefix} Status: ${response.status}`);
                        httpStatus = response.status;
                        response.headers.forEach((headerValue, headerKey) => {
                            httpResponseHeader[headerKey] = headerValue;
                        });
                        if (response.status != 200) {
                            throw new ServiceError(response.status + " " + response.statusText, httpStatus);
                        } else {
                            return response.json();
                        }
                    })
                    .then((data) => {
                        logger.debug(`${context.logPrefix} Response: ${JSON.stringify(data)}`);
                        if (data.mBoolean == true) {
                            throw new ServiceError(data.errorMessage, httpStatus);
                        }
                        else if (data[0]) {
                            if (data[0].mboolean || data[0].mBoolean || data[0].validate == false) {
                                const errorMessage = data[0].validate == false ? data[0].message : data[0].errorMessage;
                                throw new ServiceError(errorMessage, httpStatus, data);
                            }
                        }
                        else if (data.validate == false) {
                            throw new ServiceError(data.message, httpStatus);
                        }
                        else if (data.errorBlock) {
                            if (data.errorBlock.mBoolean == true) {
                                throw new ServiceError(data.errorBlock.errorMessage, httpStatus);
                            }
                            else if (data.errorBlock.mBoolean == undefined) {
                                throw new ServiceError(data.errorBlock.description, httpStatus);
                            }
                        }
                        return { data, httpResponseHeader, httpStatus };
                    })
                    .catch((e) => {
                        logger.error(`${context.logPrefix} Error: ${e.message}`);
                        return Promise.reject(e);
                    })
            }
        },
        actions: {
            receiveEvent: assign((_context, event) => {
                return {
                    url: event.value.url,
                    parameter: event.value.parameter,
                    success: event.value.success,
                    failure: event.value.failure,
                    request: event.value.request,
                    header: event.value.header,
                    logPrefix: event.value.logPrefix
                }
            })
        }
    }
);

const trigger = (context, url, request, parameter, header, success, failure) => {
    const loginUserId = context?.header.loginUserId ? context.header.loginUserId : "";
    const loginBranch = context?.header.loginBranch ? context.header.loginBranch : "";
    const logPrefix = loginBranch + '-' + loginUserId;
    if (parameter && typeof parameter === "object" && !Array.isArray(parameter) && (request == "GET" || request == "DELETE")) {
        url = url + "?" + new URLSearchParams(parameter);
        parameter = "";
    }
    if (header && typeof header === "string") {
        failure = success
        success = header
        header = {}
    }
    const service = tokenMapper[url.split('/')[3]];
    getToken(process.env[service]).then((token) => {

        header["Authorization"] = `Bearer ${token}`;
        if (header && !header["Content-Type"]) {
            header["Content-Type"] = "application/json"
        }
        context.fetch.send({
            type: "FETCH",
            value: { url, request, parameter, header, success, failure, logPrefix }
        });


    })
        .catch(e => {
            logger.info("ERROR", e)
        })
};

exports.FetchActor = FetchActor;
exports.trigger = trigger;