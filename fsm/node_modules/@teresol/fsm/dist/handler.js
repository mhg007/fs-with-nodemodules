const { interpret } = require("xstate");
const { parseJwt } = require("./auth");
const { getLogger } = require("./logging.js");
const logger = getLogger("handler.js");
const express = require("express");
const schedule = require('node-schedule');
const cors = require("cors");
const { getSession } = require("./auth");
const Busboy = require("busboy");
var r = 0;
const keys = [];
const { getToken } = require("./auth");
const fetch = (url, options) => import("node-fetch").then(({ default: fetch }) => fetch(url, options));

/**
 * Keeps a list of all active FSMs for a use case. For each request identifies the correct FSM
 * and proxies the request to the identified FSM. Each FSM is identified by a unique session id.
 * If an FSM for a session id does not exis then this handler will create an FSM for that session
 * id.
 * 
 * @param {import("xstate").MachineSchema} machine - FSM representing a use case 
 * @param {express.Request} req - http request object 
 * @param {express.Response} res  - http response object
 * @returns {express.Response} json response
 */


function removeExpiredKeys() {
    const currentTime = Date.now();
    for (const key in keys) {
        if (currentTime - keys[key].updatedAt > (((process.env.SCHEDULER_TIME * 60) * 60) * 1000)) {
            delete keys[key];
        }
    }
}
const rule = new schedule.RecurrenceRule();
rule.hour = process.env.SCHEDULER_TIME;
schedule.scheduleJob(rule, () => {
    removeExpiredKeys();
});

function handler(machine, req, res) {
    let httpReq = req.body;
    let key = parseJwt(req.headers.authorization).sid;
    if (key) {
        if (key in keys) {
            keys[key].res = res;
            var service = keys[key].service;
            var jsonObj = httpReq.data;
            var contentType = req.headers["content-type"];
            if (req.is("multipart/form-data")) {
                logger.debug(`Received Multipart Form Data`);
                const formDataObject = {
                    files: [],
                    type: null
                };
                const busboy = Busboy({ headers: req.headers });
                const buffers = {};
                busboy.on("field", (name, value) => {
                    if (name == "transition") {
                        logger.debug(`Front-End transition = ${value}`);
                        formDataObject.type = value;
                    }
                    else {
                        formDataObject[name] = value;
                    }
                });
                busboy.on("file", (field, file, fileInfo) => {
                    buffers[field] = [];
                    const { filename, encoding, mimeType } = fileInfo;
                    file.on("data", (data) => {
                        buffers[field].push(data);
                    })
                    file.on("end", () => {
                        formDataObject.files.push({
                            field: field,
                            data: Buffer.concat(buffers[field]),
                            mimeType: mimeType,
                            filename: filename,
                            encoding: encoding,
                        })
                    })
                });
                busboy.on('close', () => {
                    logger.debug('Finished parsing multipart form data');
                    service.send({
                        formDataObject,
                        type: formDataObject.type,
                        contentType: contentType
                    });
                });
                req.pipe(busboy);
            }
            else {
                logger.debug(`Data from Front-End = ${JSON.stringify(jsonObj)} `);
                logger.debug(`Front-End transition = ${httpReq.transition}`);
                service.send({
                    ...jsonObj,
                    type: httpReq.transition,
                });
            }

        } else {
            keys[key] = {
                service: null,
                res: res,
                updatedAt: '',
                sendingFunction: (ctx, myKey) => {
                    var resp = keys[myKey].res;
                    if (!resp.headersSent) {
                        r++;
                        resp.json(ctx);
                    }
                },
            };
            const newMachine = machine.withConfig({
                actions: {
                    sendCtx: (context, event) => {
                        keys[key].sendingFunction(context, key);
                        keys[key].updatedAt = Date.now();
                    },
                },
                services: {
                    sendFile: async (context, event, { data }) => {
                        let apiURL = data.url;
                        let fetchOptions = {
                            method: "GET",
                            headers: { "Content-Type": "application/json" },
                            mode: "cors",
                        };
                        if (data.secret) {
                            fetchOptions.headers.Authorization = `Bearer ${await getToken(data.secret)}`;
                        }
                        if (data.method) {
                            fetchOptions.method = data.method;
                        };
                        if (data.headers) {
                            fetchOptions.headers = data.headers;
                        };
                        if (data.params) {
                            fetchOptions.body = JSON.stringify(data.params);
                        }
                        const url = new URL(apiURL);
                        const queryParams = new URLSearchParams(url.search);
                        if (fetchOptions.method == "POST" || fetchOptions.method == "PUT") {
                            logger.info(`${fetchOptions.method} ${url.hostname}${url.pathname}`);
                            logger.debug(`Parameters: ${fetchOptions.body}`);
                        }
                        else {
                            logger.info(`${fetchOptions.method} ${url.hostname}${url.pathname}`);
                            logger.debug(`Parameters: ${queryParams}`);
                        }
                        return await fetch(apiURL, fetchOptions)
                            .then((response) => {
                                logger.info(`Status: ${response.status}`);
                                if (response.status != 200) {
                                    throw new Error(
                                        "Service Error: " +
                                        response.status +
                                        " " +
                                        response.statusText
                                    );
                                } else {
                                    return response.body;
                                }
                            })
                            .then((body) => {
                                body.pipe(keys[key].res)
                            })
                            .catch((e) => {
                                logger.error(`Error: ${e.message}`);
                                return Promise.reject(e.message);
                            });
                    },
                },
            });
            var service = interpret(newMachine);
            service.start();
            keys[key].service = service;

            service.onTransition((state) => {
                logger.debug(`NextEvents: = ${state.nextEvents}`);
            });

            var jsonObj = httpReq.data;

            if (jsonObj.header) {
                jsonObj.header.loginBranch = req.headers["X-Decoded-BranchCode"];
                jsonObj.header.loginUserId = req.headers["X-Decoded-UserId"];
                jsonObj.header.loginBranchName = req.headers["X-Decoded-LoginBranchName"];
                jsonObj.header.loginBranchDate = req.headers["X-Decoded-LoginBranchDate"] ? req.headers["X-Decoded-LoginBranchDate"] : jsonObj.header.loginBranchDate;
                jsonObj.header.loginUserBatch = req.headers["X-Decoded-LoginUserBatch"] ? req.headers["X-Decoded-LoginUserBatch"] : jsonObj.header.loginUserBatch;
                jsonObj.header.subBranchCode = req.headers["X-Decoded-SubBranchCode"];
                jsonObj.header.loginUserIp = req.headers["X-Decoded-IpAddress"] ? req.headers["X-Decoded-IpAddress"] : jsonObj.header.loginUserIp;
                jsonObj.header.batchStatus = req.headers["X-Decoded-BatchStatus"];
            }

            logger.debug(`Data from Front-End = ${JSON.stringify(jsonObj)} `);

            service.send({
                ...jsonObj,
                type: httpReq.transition,
            });
            service.onStop(() => {
                logger.info("---------------------!!! Machine STOPPED !!!---------------------");
                delete keys[key];
            });
            logger.debug(`Front-End transition = ${httpReq.transition}`);
        }
    } else {
        logger.info("Request Token key is missing!");
        return res.json("Request Token key is missing!");
    }
}

/**
 * Returns an express application.
 * 
 * @param {import("express-session").MemoryStore} memoryStore 
 * @param {import("keycloak-connect").Keycloak} keycloak 
 * @returns {import("express").Express} express application
 */
function httpServer(memoryStore, keycloak) {
    const app = express();
    app.use(getSession(memoryStore));
    app.use(keycloak.middleware());
    app.use(cors());
    app.use(express.urlencoded({ extended: false }));
    app.use(express.json({ limit: "256mb" }));
    return app;
}

module.exports = { handler, httpServer };