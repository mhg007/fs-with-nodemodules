# Introduction
This package provides the base level code that can be used by all FSM implementations. This makes it possible
to reuse commonly used machines as actors along with common functions for auth, logging and a basic 
express application configuration. The examples in this document are deliberately kept terse. Therefore, use 
them only as a guide.

## How To Use:
Configure npm to fetch npm modules from Teresol's npm registry. Please contact your team lead for these instructions.

### Installing This Module
```bash
npm install @teresol/fsm
```

## Main Components

### base.js:
The central location from where all modules are exported for the client code. This serves two purposes:
1. Prevents namespace pollution as clients only import modules from a central location.
2. Hides internal packaging structure from the client code.

### auth.js
Functions that deal with authentication. This includes checking for allowed activities, keycloak settings and 
getting auth tokens.

### handler.js
Functions related to the express server and request handler. This includes:
1. httpServer: Returns an instance of express application.
```javascript
const session = require("express-session");
const { authorize, getLogger, getKeyCloak, handler, httpServer } = require("@teresol/fsm");
const machine = require("./OBS_CC_UC5_CC_RC_FSM");

const memoryStore = new session.MemoryStore();
const keycloak = getKeyCloak(memoryStore);
const app = httpServer(memoryStore, keycloak);
```
2. handler: An http request when received is proxied to this handler.

```javascript
app.post("/fsm/obs-cc-uc5-cc-rc", keycloak.protect(), authorize("TELLER", "CCCCRC"),
	(req, res) => {
		handler(machine, req, res);
	}
);

app.listen(process.env.PORT, () => {
	logger.info(`Example app listening at ${process.env.FSM}:${process.env.PORT}`);
});
```

### logging.js
Returns a logger. This package uses winston for logging.
```javascript
const { getLogger } = require("@teresol/fsm");

const logger = getLogger("server.js");

logger.info(`Example app listening at ${process.env.FSM}:${process.env.PORT}`);
```

### service.js
Use the ```Service``` class to generate URLS. Do not manually create urls in your FSMs.
Configure ```Service``` class instance as follows.

- Provide a list of ```core-api-service``` and its ```endpoint``` as shown in example below
- The first index must be the ```core-api-service``` and the second index must be the ```desired endpoint```
- Use ```service.get("your-desired-endpoint")``` to get its url.
- If ```process.env.API_VERSION``` is undefined then the URL will be generated without the version
- If ```process.env.API_VERSION``` is set then the URL will be generated for that version


```javascript
const service = new Service();
service.addList([

    ["core-api-branch", "branchDetail"],
    ["core-api-currency", "currencyDetail"],
    ["core-api-currency", "validateCurrencyExchangeRate"],
    ["core-api-account", "accountDetail"],
    ["core-api-account", "validateAccount"],
    ["core-api-account", "validateAccountCondition"],
    ["core-api-fundsTransfer", "validateTransaction"],
    ["core-api-product", "validateProductCondition"]
]);
```


```javascript
// If process.env.API_VERSION is undefined then urls will be generated without version
let branchDetail = service.get("branchDetail"); // https://API_GATEWAY/core-api-branch/branchDetail
let currencyDetail = service.get("currencyDetail"); //https://API_GATEWAY/core-api-currency/currencyDetail 
let accountDetail = service.get("accountDetail"); //https://API_GATEWAY/core-api-account/accountDetail
```
```javascript
// If process.env.API_VERSION is set to v2 then urls will be generated with the version
let branchDetail = service.get("branchDetail"); // https://API_GATEWAY/core-api-branch/v2/branchDetail
let currencyDetail = service.get("currencyDetail"); //https://API_GATEWAY/core-api-currency/v2/currencyDetail 
let accountDetail = service.get("accountDetail"); //https://API_GATEWAY/core-api-account/v2/accountDetail
```


### fetchActor.js: 
A state machine for sending http requests and receiving their responses. This state machine is identified
by the name ```FetchActor```. The fetchActor MUST ALWAYS EXIST ON PROPERTY ```fetch``` of the machine's context.
This is by convention, and if this convention is not followed then this machine will crash. Also by convention 
the FetchActor returns the result from an API call in ```event.result``` property.

It also exposes a function named ```trigger```. This function is used by client code to send API requests. 
The ```trigger``` function proxies API requests and responses between the client code and the APIs.

```javascript
const { createMachine, assign, spawn } = require("xstate");
const { FetchActor, trigger, Service } = require("@teresol/fsm");

/**
 * Urls must be kept in a separate file urls.js in your project root. 
 * Here it is shown inline for the sake of example.
 */
const service = new Service();

service.addList([
    ["core-api-batch", "validateBatch"],
    ["core-api-branch", "branchDetail"]
]);

const validateBatch = service.get("validateBatch");
const branchDetail = service.get("branchDetail"); 

const machine = createMachine({
    id: "TLR_PC_UC1_CHQ",
    predictableActionArguments: true,
    initial: "Idle",
    context: {
        branch: null
    },
    states: {
      BatchStatus: {
        entry: [
          /** 
           * Always assign the FetchActor to the 'fetch' property of the context.
          */
          assign({
            fetch: () => spawn(FetchActor)
          }),
          async (context) => {
            /** 
             * The trigger function proxies http requests to the FetchActor. This function must be passed 
             * following parameters:
             * - context of the machine making the request
             * - request url
             * - http Method
             * - request Body in case of POST/PUT method. For GET each key value pair will be interpreted as a query param
             * - http Headers (If no Content-Type is specified then Content-Type defaults to application/json)
             * - string literal identifying the success handler
             * - string literal identifying the failure handler
            */
            trigger(
              context,
              validateBatch,
              "POST",
              {
                req_branchCode: context.header.loginBranch,
                userID: context.header.loginUserId,
                res_response: ["batchNumber", "batchStatus"],
                opt_identifier: "status",
              },
              {
                "Content-Type": "application/json",
                Authorization: `Bearer ${await getToken(process.env.CORE_API_BATCH)}`,
              },
              "FETCH_SUCCESS",
              "FETCH_FAILURE"
            );
          }
        ],
        on: {
          FETCH_SUCCESS: {
            actions: ["receiveBatchStatus"],
            assign({
                batchStatus: (context, event) => event.result[0].batchStatus,
            }),
            target: "MegaSet18"
          },
          FETCH_FAILURE: {
            actions: ["receiveMessage", "sendCtx"],
            target: "Final"
          }
        }
      }
    }
  }
)
```

For ```GET``` requests the trigger function has a similar signature. The only difference is in the semantics.
The key value pairs in the fourth argument will be interpreted as query parameters and not request body. The
url will be percent encoded.
```javascript
  trigger(
    context,
    branchDetail,
    "GET",
    {
        branchCode: context.header.loginBranch,
        dbIdentifier: "TELLER",
        caseIdentifier: "BRN01-0029",
        bankCode: "1",
        activeBank: "Y",
        res_response: "BRN_NAME,BRN_CD"
    },
    {
        Authorization: `Bearer ${await getToken(process.env.CORE_API_BRANCH)}`,
    },
    "FETCH_SUCCESS",
    "FETCH_FAILURE"
  );
```

### fundTransferActor.js
A state machine for sending http requests to the FundTransfer API.

### fundTransferProcedureActor.js
A state machine that runs create matrix and executes fund transfer. It depends on fundTransferActor to
carry out fund transfer api specific calls. The following is a brief summary on using this machine.

Importing FundTransferProcedure actor:
```javascript
const { FundTransferProcedureActor } = require("@teresol/fsm");
```

Assigning FundTransferPrecodure actor to a property on context:

```javascript
assign( { fundTransferProcedureActor: () => spawn(FundTransferProcedureActor) } )
```

Initializing a fundTransferProcedureActor, and sending it the DTO. NOTE: By convention this machine expects to pick up the DTO from its context  using ```context.requestDTO["0"]```. If convention is not followed then either
the machine will crash or work improperly.

```javascript
if (context.fundTransferProcedureActor.state.value == "Idle") {
        context.fundTransferProcedureActor.send({
            type: "INIT",
            requestDTO: context.requestDTO,
    });
}
```

Sending CONTINUE on Exception Screen.

```javascript
context.fundTransferProcedureActor.send({
    type: "CONTINUE",
    value: "",
});
```

To kill this machine you can send the ```KILL``` event.
```javascript
context.fundTransferProcedureActor.send({ type: "KILL" });
context.fundTransferProcedureActor = null;
```

### File Handling Example
Example for downloading pdf files. Here File is a state.

```javascript
File: {
        invoke: {
          id: "sendFile",
          src: "sendFile",
          data: {
            url: (context) => getReport +
              "/VOUCHER_GB?output=pdf&reportInputs=voucherNumber=" + 100029 + ",voucherYear=" + 2021 + ",branchCode=" + 2017 + ",currencyCode=" + 586 + ",branch=" + "KARACHI-MAIN" + ",userID=" + context.header.loginUserId,
            secret: process.env.CORE_API_REPORT
          },
          onDone: {
            actions: [ "setmbooleanFalse" ]
          },
          onError: {
            target: "MegaSet9",
            actions: [
              assign({
                mBoolean: true,
                errorMessage: (context, event) => {
                  return event.data
                }
              }),
              "sendCtx"
            ]
          }
        },
      },

```
### Triggering A Multi Part Form Data Request
The following example shows how to proxy a multipart/form-data request to a service.
```javascript
trigger(
  context,
  tempUpload,
  "POST",
  payloadData,
  {
    "Content-Type": "multipart/form-data",
    Authorization: `Bearer ${await getToken(process.env.CORE_API_FILE)}`,
  },
  "FETCH_SUCCESS",
  "FETCH_FAILURE"
)
```
***NOTE:***     
The multipart/form-data request must contain a field ```transition.``` This field will map to an ```xstate``` transition. Following is a CURL example to upload test3.jpg file on receiving a transition ```MEGASET95_UPLOAD_DOCUMENTS```
```bash
curl --location --request POST 'http://localhost:3500/fsm/TLR_TF_UC37_TF_FrxRmt_Owd_Brn_Act_scanD' \
--header 'Authorization: Bearer Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJPbmxpbmUgSldUIEJ1aWxkZXIiLCJpYXQiOjE2NjI1MjQ1MjAsImV4cCI6MTY5NDA2MDUyMCwiYXVkIjoid3d3LmV4YW1wbGUuY29tIiwic3ViIjoianJvY2tldEBleGFtcGxlLmNvbSIsInNpZCI6Ijg1NTE1ZjgyNDg5YjRhYjk5OTRiYmY3ZDM1ODg1YjY4In0.-7Zh30Qb0_df3R0h0HzWijZiJHr0HeU0pxm1XW8fdiM' \
--header 'Cookie: connect.sid=s%3ATunJFOUJDQvzFw45dg1LQwWZw87WesQd.mW0vqA%2FB5lt4l%2FacCNsOGv7RTdPRdSwtIBpNahNCeMs' \
--form 'document=@"/home/pc/Desktop/test3.jpg"' \
--form 'documentCategory="jpg"' \
--form 'transition="MEGASET95_UPLOAD_DOCUMENTS"' \
--form 'documentIndex="1"'
```

### Accessing Pagination Information
For services that return pagination information in Http Response Headers, one can access the entire
http response header using ```event.httpResponseHeader```. The entire Http Response header received from the
service is proxied back to the specified ```success``` action.
```javascript
{
  states: {
    GetTransactions: {
        entry: [
          "spawnFetch",
          async (context) => {
            trigger(
              context,
              fundsTransferDetailPaginated,
              "GET",
              {
                connectionBranch: 1030,
                caseIdentifier: "FTR02-092",
                fromPostDate: "2022-02-05",
                toPostDate: "2022-02-10",
                branchCode: 1030,
                identifier: "A",
                mainHead: "010",
                subHead1: "01", 
                subHead2: "01",
                generalLedgerRunNumber: "1000",
                generalLedgerCheckDigit: "2",
                activityCode: "crm",
                page: 1,
                pageSize:10
              },
              {
                "Content-Type": "application/json",
                Authorization: `Bearer ${await getToken(process.env.CORE_API_FUNDSTRANSFER)}`
              },
              "FETCH_SUCCESS",
              "FETCH_FAILURE"
            )
          }
        ],
        on: {
          FETCH_SUCCESS: {
            actions: [
              assign({
                transactions: (context, event) => {
                  return event.result;
                },
                httpResponseHeader: (context, event) => {
                  return event.httpResponseHeader;
                }
              }),
              "sendCtx"
            ]
          },
          FETCH_FAILURE: {
            actions: ["receiveMessage", "sendCtx"]
          }
        } 
      }
  }
}
```

### Special Case For Validating Conditions Applied To An Account
The following example illustrates a special case of validating conditions applied on an account. For this particular
endpoint an additional property ```errorResponse``` is sent to the action that handles the failure path of the api call.

```javascript
{
  states: {
    CheckAccountConditions: {
      entry: [
            "spawnFetch",
            async (context) => {
                /* teller.TfunParamterCust:19381 â€“ 19678 */
                let accountNumber = context.selectedAccountNumber.split("-");
                const accountConditionCodes = [
                    16, // Account is closed
                    15, // Account is in closing state
                    93, // Account opening is in process
                ];
                if(accountNumber[1] !== "0082" || accountNumber[1] !== "0080") {
                    accountConditionCodes.push(18); // Account is blocked
                }
                trigger(
                    context,
                    validateAccountCondition,
                    "POST",
                    {
                        branchCode: accountNumber[0],
                        accountType: accountNumber[1],
                        customerNumber: accountNumber[2],
                        runNumber: accountNumber[3],
                        checkDigit: accountNumber[4],
                        loginBranch: context.header.loginBranch,
                        userId: context.header.loginUserId,
                        batchNumber: context.header.loginUserBatch,
                        activityCode: context.header.activityCode,
                        conditionCode: accountConditionCodes.join(","),
                        response: ["conditionCode"]
                    },
                    {
                        "Content-Type": "application/json",
                        Authorization: `Bearer ${await getToken(process.env.CORE_API_ACCOUNT)}`
                    },
                    "FETCH_SUCCESS",
                    "FETCH_FAILURE"
                );
          }
        ],
        on: {
            FETCH_SUCCESS: {
                target: "Final"
            },
            FETCH_FAILURE: [
                {
                    target: "Final",
                    cond: (context, event) => typeof event.errorMessage === "string" && event.errorMessage.includes("ACC09-006"),
                },
                {
                    target: "Final",
                    actions: assign({
                      errorMessage: (context, event) => {
                        return event.errorMessage;
                      },
                      mBoolean: (context, event) => {
                        return event.mBoolean
                      },
                      errorResponse: (context, event) => {
                        return event.errorResponse;
                      }
                    })
                }
            ]
        }
    }
  }
}
```