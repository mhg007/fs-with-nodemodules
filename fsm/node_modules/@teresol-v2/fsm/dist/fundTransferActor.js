const { assign, createMachine, sendParent } = require("xstate");
const { getLogger } = require("./logging.js");
const logger = getLogger("fundTransferActor");
const fetch = (url, options) => import("node-fetch").then(({ default: fetch }) => fetch(url, options));

const FundTransferActor = createMachine(
	{
		id: "Fund_Transfer_Actor",
		predictableActionArguments: true,
		initial: "Idle",
		context: {
			url: "",
			requestMethod: "",
			parameter: [],
			success: "",
			failure: "",
			exception: "",
			response: "ok",
			errorMessage: "error",
			mBoolean: false,
			data: {
				some: "data",
				to: "test",
				fetch: "machine",
			},
			warnings: [],
		},
		states: {
			Idle: {
				on: {
					FT_FETCH: {
						actions: ["recieveArgs"],
						target: "GetData",
					}
				},
			},
			GetData: {
				invoke: {
					id: "GetData",
					src: "getData",
					onDone: [
						{
							cond: (context, event) => {
								return context.exception != undefined
							},
							target: "CheckForException",
						},
						{
							target: "Final",
							actions: sendParent((context, event) => ({
								...context,
								type: context.success,
							})),
						}
					],
					onError: {
						target: "Final",
						actions: sendParent((context, event) => ({
							...context,
							type: context.failure,
						})),
					},
				},
			},
			CheckForException: {
				invoke: {
					id: "Check for Exception",
					src: "checkForException",
					onDone: {
						target: "Final",
						actions: sendParent((context, event) => ({
							...context,
							type: context.success,
						})),
					},
					onError: {
						target: "Final",
						actions: sendParent((context, event) => ({
							...context,
							type: context.exception ? context.exception : context.success,
						})),
					},
				},
			},
			Final: {
				type: "final",
			},
		},
	},
	{
		services: {
			getData: (ctx) => {
				logger.info(`${ctx.requestMethod} ${ctx.url}`);
				logger.debug(`Parameters: ${JSON.stringify(ctx.parameter)}`);
				return fetch(ctx.url, {
					method: ctx.requestMethod,
					...((ctx.requestMethod == "POST" || ctx.requestMethod == "PUT") && {
						body: JSON.stringify(ctx.parameter),
					}),
					headers:
						JSON.stringify(ctx.header) == JSON.stringify(ctx.emptyHeader)
							? { "Content-Type": "application/json" }
							: ctx.header,
					mode: "cors",
				})
					.then((response) => {
						logger.info(`Status: ${response.status}`);
						if (response.status != 200) {
							throw new Error(response.status + " " + response.statusText);
						} else {
							return response.json();
						}
					})
					.then((data) => {
						logger.debug(`Response: ${JSON.stringify(data)}`);
						if (data.errorBlock) {
							var err =
								"Error code=" +
								data.errorBlock.code +
								" Error description=" +
								data.errorBlock.description;
							throw new Error(err);
						} else {
							ctx.data = data;
						}
					})
					.catch((e) => {
						logger.error(`Error: ${e.message}`);
						if (e.message == "Unexpected end of JSON input") {
							ctx.errorMessage = "Please Try Again";
						}
						else {
							ctx.errorMessage = e.message;
						}
						ctx.mBoolean = true;
						return Promise.reject();
					});
			},
			checkForException: (ctx) => {
				return new Promise((resolve, reject) => {
					var isException = false;
					var isWarning = true;
					var warnings = [];
					if (ctx.data.header?.instantPostingAllowed == true && ctx.data.header?.instantAuthorizationAllowed == true) {
						isWarning = true;
					}
					else if (ctx.data.header?.instantPostingAllowed == false && ctx.data.header?.instantAuthorizationAllowed == false) {
						isWarning = true;
					}
					else if (ctx.data.header?.instantPostingAllowed == true && ctx.data.header?.instantAuthorizationAllowed == false) {
						isWarning = false;
						return resolve();
					}

					if (isWarning) {
						for (var index in ctx.data.transactionLegs) {
							transactionLeg = ctx.data.transactionLegs[index];
							if ("warning" in transactionLeg) {
								isException = true;
								warnings.push(...transactionLeg.warning);
							}
						}
						if (isException) {
							var uniqueWarnings = [
								...new Map(
									warnings.map((item) => [item["warningCode"], item])
								).values(),
							];
							ctx.warnings = uniqueWarnings;
							reject();
						} else {
							resolve();
						}
					}
				});
			},
		},
		actions: {
			recieveArgs: assign({
				url: (context, event) => event.value.url,
				parameter: (context, event) => {
					return event.value.parameter;
				},
				header: (context, event) => {
					return event.value.header;
				},
				requestMethod: (context, event) =>
					event.value.requestMethod.toUpperCase(),
				success: (context, event) => event.value.success,
				failure: (context, event) => event.value.failure,
				exception: (context, event) => event.value.exception,
			}),
		},
	}
);

exports.FundTransferActor = FundTransferActor;