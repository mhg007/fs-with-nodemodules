const { getLogger } = require("./logging.js");
const axios = require("axios");
const memoize = require("memoizee");
const Keycloak = require("keycloak-connect");
const session = require("express-session");
const querystring = require("querystring");

const logger = getLogger("auth.js");

/**
 * Returns allowed activties of a user. Allowed activities determine what actions
 * a logged in user can perform.
 * 
 * @async 
 * @typedef UserActivities
 * @property {Array.<String>} allowedActivities
 * @param {string} token - keycloak token
 * @returns {UserActivities} An object containing list of allowed user activities
 */
function _getUsersAllowedAcivities(token) {
	return new Promise(async (resolve, reject) => {
		try {
			const response = await axios.get(
				process.env.AUTH_TOKEN_KEYCLOAK +
				"/auth/realms/ahbs-realm/protocol/openid-connect/userinfo",
				{
					headers: {
						Authorization: "Bearer " + token,
					},
				}
			);
			resolve(response.data);
		} catch (err) {
			logger.error("getUsersAllowedAcivities", err);
			reject(err);
		}
	});
}
const getUsersAllowedAcivities = memoize(_getUsersAllowedAcivities, {
	promise: true,
	maxAge: 3 * 60 * 1000 - 50,
});
/**
 * Wrapper around express session object. Returns express session.
 * 
 * @param {import("express-session").MemoryStore} memoryStore 
 * @param {string} [secret="some secret"] - secret 
 * @returns {import("express").RequestHandler} ExpressSession
 */

function getSession(memoryStore, secret) {
	if (!secret) secret = "some secret";
	return session({
		secret: secret,
		resave: false,
		saveUninitialized: true,
		store: memoryStore,
	})
}

/**
 * Checks if the given activityCode is in the allowed activities for a given user. The use case will 
 * execute further only if a user is allowed to perform the sought activity. 
 * The _moduleCode field is for historical purposes. Although unused, making it optional will break
 * previously running client code. Therefore, do not remove _moduleCode. 
 * @async
 * @param {string} _moduleCode name of module e.g TELLER
 * @param {string} activityCode
 */
const authorize = (_moduleCode, activityCode) => {
	return async (req, res, next) => {
		try {
			const token = req.headers.authorization.split(" ")[1];
			const allowedActivities = await getUsersAllowedAcivities(token);
			let activityCodeFound = false;
			if (Array.isArray(activityCode)) {
				if (activityCode.some(code => allowedActivities.allActivities.includes(code))) {
					activityCodeFound = true
				}
			} else {
				if (allowedActivities.allActivities.includes(activityCode)) {
					activityCodeFound = true
				}
			}
			if (activityCodeFound) {
				req.headers["X-Decoded-WindowId"] = allowedActivities.windowId ? allowedActivities.windowId : "";
				req.headers["X-Decoded-BranchCode"] = allowedActivities.branchCode;
				req.headers["X-Decoded-UserId"] = allowedActivities.userId;
				req.headers["X-Decoded-BranchTypeName"] = allowedActivities.branchTypeName ? allowedActivities.branchTypeName : null;
				req.headers["X-Decoded-LoginBranchName"] = allowedActivities.loginBranchName ? allowedActivities.loginBranchName : null;
				req.headers["X-Decoded-LoginBranchDate"] = allowedActivities.branchDate ? allowedActivities.branchDate : null;
				req.headers["X-Decoded-LoginUserBatch"] = allowedActivities.batchResponseDTO[0].batchNumber ? allowedActivities.batchResponseDTO[0].batchNumber : null;
				req.headers["X-Decoded-SubBranchCode"] = allowedActivities.subBranchCode ? allowedActivities.subBranchCode : 0;
				req.headers["X-Decoded-IpAddress"] = allowedActivities.ipAddress ? allowedActivities.ipAddress : "";
				req.headers["X-Decoded-BatchStatus"] = allowedActivities.batchResponseDTO[0].batchStatus ? allowedActivities.batchResponseDTO[0].batchStatus : "";
				next();
			}
			else {
				throw `Activity code ${activityCode} not found in list of allowed activities`;
			}
		} catch (err) {
			if (err.message) logger.error("authorize", err.message);
			else logger.error("authorize", err);
			res.status(401).json({
				error: new Error("User not authorized."),
			});
		}
	};
};

/**
 * Returns access token for an API
 * @async
 * @param {string} secret - API Secret
 * @returns {string} access token
 */
const _getToken = (secret) => {
	return new Promise(async (resolve, reject) => {
		try {
			const tokenResponse = await axios.post(
				process.env.GET_TOKEN + "/auth/realms/ahbs-realm/protocol/openid-connect/token",
				querystring.stringify({
					grant_type: "client_credentials",
				}),
				{
					headers: {
						"Content-Type": "application/x-www-form-urlencoded",
						Authorization: "Basic " + secret
					},
				}
			);
			return resolve(tokenResponse.data.access_token);
		} catch (err) {
			logger.error("Service getToken error", err);
			reject(err);
		}
	});
};


const getToken = memoize(_getToken, {
	promise: true,
	maxAge: 3 * 60 * 1000 - 50,
});

/**
 * Returns a Keycloak instance
 * 
 * @param {import("express-session").MemoryStore} memoryStore 
 * @param {string} [resource="fsm-credit-card-inquiry"] - keycloak resource
 * @returns {import("keycloak-connect").Keycloak} Keycloak instance
 */
function getKeyCloak(memoryStore, resource) {
	if (!resource) resource = "fsm-credit-card-inquiry";
	const keyCloakConfig = {
		realm: "ahbs-realm",
		"bearer-only": true,
		"auth-server-url": process.env.AUTH_TOKEN_SERVER + "/auth/",
		"ssl-required": "external",
		resource: resource,
		"confidential-port": 0,
	};
	return new Keycloak({ store: memoryStore }, keyCloakConfig);
}

/**
 * Extracts and returns session information from the given token. Internally uses  
 * @see {@link JSON.parse} to create a session object.
 * 
 * @typedef {Object} Session
 * @property {string} sid - unique session identifier
 * @param {string} token - Keycloak token
 * @returns {Session} Session information
 */
function parseJwt(token) {
	return JSON.parse(Buffer.from(token.split(".")[1], "base64").toString());
}

module.exports = {
	getToken,
	authorize,
	getKeyCloak,
	getSession,
	parseJwt
};