const { assign, createMachine, sendParent, spawn } = require("xstate");
const { FundTransferActor } = require("./fundTransferActor");
const { getToken } = require("./auth.js");
const Service = require("./service");

let service = new Service();
service.addList([
    ["core-api-matrix", "createMatrix"],
    ["core-api-fundsTransfer", "executeFundsTransfer"],
    ["core-api-matrix", "authorizeMatrix"],
    ["core-api-fundsTransfer", "authorizeFundsTransfer"]
]);

function parseGlAccountNo(dto) {
    dto = dto.transactionResponseEntry.glDetailResponseDto;
    if (!!!dto)
        return ""
    var acNo = "";
    acNo += dto.identity + "-";
    acNo += dto.mainHead?.toString().padStart(3, 0) + "-";
    acNo += dto.subHead1?.toString().padStart(2, 0) + "-";
    acNo += dto.subHead2?.toString().padStart(2, 0) + "-";
    acNo += dto.runNumber?.toString().padStart(4, 0) + "-";
    acNo += dto.checkDigit;
    return acNo;
}

function parseAccountNo(dto) {
    dto = dto.transactionResponseEntry.accountDetailResponseDto;
    if (!!!dto)
        return ""
    var acNo = "";
    acNo += dto.branchCode?.toString().padStart(4, 0) + "-";
    acNo += dto.accountType?.toString().padStart(4, 0) + "-";
    acNo += dto.customerNumber?.toString().padStart(6, 0) + "-";
    acNo += dto.runNumber?.toString().padStart(2, 0) + "-";
    acNo += dto.checkDigit;
    return acNo;
}

function isDebit(transLeg) {
    return transLeg.transactionResponseEntry.debitCredit.toLowerCase() == "debit";
}

function isGL(transLeg) {
    return transLeg.transactionResponseEntry.acIden == "G";
}
function getAccountTitle(transLeg) {
    var dto;
    if (isGL(transLeg)) {
        dto = transLeg.transactionResponseEntry.glDetailResponseDto;
        if (!!!dto)
            return ""
        return dto.accountName;
    } else {
        dto = transLeg.transactionResponseEntry.accountDetailResponseDto;
        if (!!!dto)
            return ""
        return dto.accountTitle;
    }
}

function collectVouchers(responseDTO) {
    const vouchers = [];
    for (const index in responseDTO.transactionLegs) {
        const transLeg = responseDTO.transactionLegs[index];
        const amount = transLeg.transactionResponseEntry.amount;
        const voucher = {
            documentNumber: transLeg.transactionResponseEntry.documentNumber,
            documentYear: transLeg.transactionResponseEntry.documentYear,
            voucher_no:
                transLeg.transactionResponseEntry.voucherNumber +
                "/" +
                transLeg.transactionResponseEntry.voucherYear,
            trans_ref_no:
                transLeg.transactionResponseEntry.transactionStatus == 1
                    ? transLeg.transactionResponseEntry.referenceNumber
                    : transLeg.transactionResponseEntry.transactionNumber,
            tran_code: transLeg.transactionResponseEntry.transactionCode,
            inst_no: transLeg.transactionResponseEntry.instrumentNumber,
            account_no: isGL(transLeg)
                ? parseGlAccountNo(transLeg)
                : parseAccountNo(transLeg),
            account_title: getAccountTitle(transLeg),
            ccy: transLeg.transactionResponseEntry.currencyCode,
            orEntry: transLeg.transactionResponseEntry.orEntry,
            dr: isDebit(transLeg) ? amount : 0.0,
            cr: isDebit(transLeg) ? 0.0 : amount,
            serialNumber: transLeg.transactionResponseEntry.serialNumber,
            branchCode: transLeg.transactionResponseEntry.branchCode,
            settlementNumber: transLeg.transactionResponseEntry.settlementNumber,
            activityRequestNumber: transLeg.transactionResponseEntry.activityRequestNumber,
            activityNumber: transLeg.transactionResponseEntry.activityNumber,
            activityYear: transLeg.transactionResponseEntry.activityYear,
            cpuReferenceNumber: transLeg.transactionResponseEntry.cpuReferenceNumber,
            cpuVoucherYear: transLeg.transactionResponseEntry.cpuVoucherYear,
            cpuTransactionNumber: transLeg.transactionResponseEntry.cpuTransactionNumber,
            cpuVoucherNumber: transLeg.transactionResponseEntry.cpuVoucherNumber,
            adviceNumber: transLeg.transactionResponseEntry.adviceNumber

        };
        if (transLeg.intraTransactionLegInsertOptional?.[0]?.intraTranLegInsertOptObj?.waiverNumber) {
            voucher.waiver = transLeg.intraTransactionLegInsertOptional[0].intraTranLegInsertOptObj.waiverNumber + "/" + transLeg.intraTransactionLegInsertOptional[0].intraTranLegInsertOptObj.wavierYear
        }
        vouchers.push(voucher);
    }
    return vouchers;
}

function collectSettlementNumber(responseDTO) {
    let settlementNumbers = [];
    for (let index in responseDTO.transactionLegs) {
        let transLeg = responseDTO.transactionLegs[index];
        for (let intraTransactionLeg of transLeg.intraTransactionLegInsertOptional) {
            if (intraTransactionLeg.intraTranLegInsertOptObj && intraTransactionLeg.intraTranLegInsertOptObj.settlementNumber) {
                settlementNumbers.push(intraTransactionLeg.intraTranLegInsertOptObj.settlementNumber);
            }
        }
    }
    return settlementNumbers;
}

const FundTransferProcedureActor = createMachine(
    {
        id: "Fund_Transfer_Procedure_Actor",
        predictableActionArguments: true,
        initial: "Idle",
        context: {
            url: "",
            errorMessage: "",
            MegaSet_14: {},
            voucherInfo: {},
            transactionDetails: {},
            response: {},
            exceptionDetails: {},
            fetchHandle: null,
            FTFetchHandle: null,
            requestDTO: {},
            mBoolean: false,
        },
        states: {
            Idle: {
                on: {
                    INIT: {
                        target: "MakeVoucher",
                        actions: "receiveData",
                    },
                },
            },
            MakeVoucher: {
                entry: [
                    "spawnFTFetch",
                    async (ctx) => {
                        let matrixUrl = ""
                        let matrixRequestType = ""
                        if (ctx.transactionType == "" || ctx.transactionType == undefined) {
                            matrixUrl = service.get("createMatrix");
                            matrixRequestType = "POST"
                        }
                        if (ctx.transactionType == "Authorize") {
                            matrixUrl = service.get("authorizeMatrix");
                            matrixRequestType = "PUT"
                        }
                        triggerFTFetch(
                            ctx.FTFetchHandle,
                            matrixUrl,
                            matrixRequestType,
                            ctx.requestDTO,
                            {
                                "Content-Type": "application/json",
                                Authorization: `Bearer ${await getToken(process.env.CORE_API_MATRIX)}`
                            },
                            "FT_FETCH_SUCCESS",
                            "FT_FETCH_FAILURE",
                            "FT_FETCH_EXCEPTION"
                        );
                    },
                ],
                on: {
                    FT_FETCH_SUCCESS: {
                        actions: ["receiveResponse"],
                        target: "DoFundTransfer",
                    },
                    FT_FETCH_FAILURE: {
                        target: "Final",
                        actions: ["receiveMessage", "sendMessage"],
                    },
                    FT_FETCH_EXCEPTION: {
                        target: "ExceptionScreen",
                        actions: ["receiveExceptionDetails", "sendExceptionDetails"],
                    },
                },
            },
            ExceptionScreen: {
                on: {
                    CONTINUE: {
                        target: "DoFundTransfer",
                        actions: ["receiveOptions"]
                    },
                    KILL: "Final",
                },
            },
            DoFundTransfer: {
                entry: [
                    "spawnFTFetch",
                    async (ctx) => {
                        let fundsTransferUrl = ""
                        let FtRequestType = ""
                        if (ctx.transactionType == "" || ctx.transactionType == undefined) {
                            fundsTransferUrl = service.get("executeFundsTransfer");
                            FtRequestType = "POST"
                        }
                        if (ctx.transactionType == "Authorize") {
                            fundsTransferUrl = service.get("authorizeFundsTransfer");
                            FtRequestType = "PUT"
                        }
                        triggerFTFetch(
                            ctx.FTFetchHandle,
                            fundsTransferUrl,
                            FtRequestType,
                            ctx.response,
                            {
                                "Content-Type": "application/json",
                                Authorization: `Bearer ${await getToken(process.env.CORE_API_FUNDSTRANSFER)}`
                            },
                            "FT_FETCH_SUCCESS",
                            "FT_FETCH_FAILURE"
                        );
                    },
                ],
                on: {
                    FT_FETCH_SUCCESS: {
                        actions: ["receiveResponse"],
                        target: "ParseVouchersDetails",
                    },
                    FT_FETCH_FAILURE: {
                        target: "ExceptionScreen",
                        actions: [
                            "receiveMessage",
                            "sendMessage"
                        ],
                    },
                },
            },
            ParseVouchersDetails: {
                entry: ["parseVouchers", "extractSettlementNumber", "sendTransactionDetails"],
                always: {
                    target: "Final",
                },
            },
            Error: {
                entry: [
                    sendParent((context, event) => ({
                        ...context,
                        type: "FAILURE",
                    })),
                ],
                always: {
                    target: "Final",
                },
            },
            Final: {
                type: "final",
            },
        }
    },
    {
        actions: {
            spawnFTFetch: assign({
                FTFetchHandle: () => spawn(FundTransferActor),
            }),

            receiveData: assign({
                requestDTO: (context, event) => {
                    return event.requestDTO;
                },
                transactionType: (context, event) => event.transactionType,
            }),
            receiveResponse: assign({
                response: (context, event) => {
                    return event.data;
                },
            }),
            sendExceptionDetails: sendParent((context, event) => {
                return {
                    ...context,
                    type: "EXCEPTION",
                };
            }),
            receiveExceptionDetails: assign({
                exceptionDetails: (context, event) => event.warnings,
                response: (context, event) => event.data,
            }),
            parseVouchers: assign({
                transactionDetails: (context, event) => collectVouchers(event.data),
            }),
            extractSettlementNumber: assign({
                settlementNumbers: (context, event) => collectSettlementNumber(event.data)
            }),
            sendTransactionDetails: sendParent((context, event) => {
                return {
                    ...context,
                    type: "VOUCHER_DETAIL",
                };
            }),
            receiveMessage: assign({
                errorMessage: (context, event) => {
                    return event.errorMessage
                },
                mBoolean: (context, event) => {
                    return event.mBoolean
                }
            }),
            sendMessage: sendParent((context, event) => ({
                ...context,
                type: "FAILURE",
            })),
            receiveOptions: assign({
                response: (context, event) => {
                    /**
                     * This function expects that an event object will have an options property.
                     * For example if the event object is
                     * {
                     *   options: {
                     *      header: {
                     *        authorizedBy: "SomeUser"
                     *      }
                     *   }
                     * }
                     * 
                     * It will extract each option from the 'options' property and add them to 
                     * the 'header' property of context.response. In the code below the 
                     * 'option' refers to the option e.g 'header' in the given example. While
                     * the 'optionValue' refers to { authorizedBy: "SomeUser" }
                     * 
                     */
                    if (event.options && typeof event.options == "object" && !Array.isArray(event.options)) {
                        let responseClone = JSON.parse(JSON.stringify(context.response));
                        for (let option of Object.keys(event.options)) {
                            let optionValue = event.options[option];
                            for (let key of Object.keys(optionValue)) {
                                let value = optionValue[key];
                                responseClone[option][key] = value;
                            }
                        }
                        return responseClone;
                    }
                    return context.response;
                }
            })
        },
    }
);

const triggerFTFetch = (FTFetchHandle, url, requestMethod, parameter, header, onSuccessEvent, onFailureEvent, onExceptionEvent) => {
    FTFetchHandle.send({
        type: "FT_FETCH",
        value: {
            url: url,
            requestMethod: requestMethod,
            parameter: parameter,
            header: header,
            success: onSuccessEvent,
            failure: onFailureEvent,
            exception: onExceptionEvent,
        },
    });
};

exports.FundTransferProcedureActor = FundTransferProcedureActor;
exports.triggerFTFetch = triggerFTFetch;