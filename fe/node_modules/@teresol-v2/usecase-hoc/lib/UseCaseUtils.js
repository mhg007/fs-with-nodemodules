import axios from 'axios';
import { useStore } from "vuex";
import { onBeforeRouteLeave, useRouter, useRoute } from 'vue-router';
import { 
    h, 
    defineComponent, 
    resolveDynamicComponent, 
    mergeProps, 
    toHandlers, 
    onBeforeMount, 
    onBeforeUnmount, 
    getCurrentInstance, 
    shallowRef, 
    ref, 
    isRef, 
    computed, 
    toValue,
    Fragment    
} from 'vue';
function isNil(value) { return (value === undefined || value === null); }
function isString(value) { return (typeof value === 'string'); }
function isObject(value) { return (typeof value === 'object'); }
function isNilOrEmpty(val) { return !(typeof val === 'string' && val !== ''); }
// Loader Component - render function
const Loader = h('div', { style: 'min-height:100px;' }, '');
// FSM Response Error Class
class FsmResponseError extends Error {
    constructor(response) {
        super(response.data.errorMessage);
        this.name = "FsmResponseError";
        this.response = response;
    }
    static assertError(response) {
        if (!isObject(response) || typeof response.status !== 'number') { throw new Error('Invalid FSM Response'); } 
        else if (response.status !== 200) { throw new Error(`Invalid FSM Response Status Code: ${response.status}`); } 
        else if (!isObject(response.data)) { throw new Error('Invalid FSM Response Data'); } 
        else if (response.data.mBoolean === true) { throw new FsmResponseError(response); }
    }
}
/****FSM AJAX Class**: The *axios* wrapper class for posting **FSM transition** requests*/
class FsmAjax {
    #_url; #_activityCode; #_subActivityCode; #_batchRequired; // Private Fields
    /** Creates an instance of FsmAjax class
     * @param { { fsmUrl: String , batchRequired: Boolean, activityCode?: String | undefined, subActivityCode?: String | undefined } } config UseCase Config  */
    constructor({ fsmUrl, batchRequired, activityCode, subActivityCode }) {
        if (isNilOrEmpty(fsmUrl)) { throw new Error('Invalid FSM URL'); } 
        else if (typeof batchRequired !== 'boolean') { throw new Error('Invalid Batch Required value'); } 
        else if (!isNil(activityCode) && !isString(activityCode)) { throw new Error('Invalid FSM Activity Code'); } 
        else if (!isNil(subActivityCode) && !isString(subActivityCode)) { throw new Error('Invalid FSM Sub Activity Code'); }
        this.#_url = fsmUrl;
        this.#_batchRequired = batchRequired;
        this.#_activityCode = activityCode ?? '';
        this.#_subActivityCode = subActivityCode ?? '';
    }
    /** Gets FSM URL */
    get url() { return this.#_url; }
    /** Gets whether Batch Required */
    get batchRequired() { return this.#_batchRequired; }
    /** Gets Activity Code */
    get activityCode() { return this.#_activityCode; }
    /** Gets Sub-Activity Code */
    get subActivityCode() { return this.#_subActivityCode; }    
    /** Posts FSM transition
     * @param {string} transition The FSM Transition
     * @param {object} [data] The payload data
     * @returns {Promise<object>} Returns response data (asynchronously) */
    async post(transition, data) {
        if (isNilOrEmpty(transition)) { throw new Error('Invalid FSM Transition'); } 
        else if (!isNil(data) && !isObject(data)) { throw new Error('Invalid FSM Data'); }
        const payloadset = { transition, data: data ?? {} };
        const response = await axios.post(this.#_url, payloadset);
        FsmResponseError.assertError(response);
        return response.data;
    }
    /** Posts FSM **`INIT`** transition
     * @returns {Promise<object>} Returns **`INIT`** response data (asynchronously) */
    postInit() {
        var header = FsmAjax.header;
        header.activityCode = this.activityCode;
        header.subActivityCode = this.subActivityCode;
        return this.post('INIT', { header });
    }
    /** Posts FSM **`KILL`** transition
     * @returns {Promise<object>} Returns **`KILL`** response data (asynchronously) */
    postKill() { return this.post('KILL'); }
    /** Gets header for **`INIT`** transition */
    static get header() { return useStore()?.getters?.getHeaders ?? {}; }
    /** Determines whether specified error is an instance of FSM Response Error or not
     * @param {Error} error The Error to evaluate
     * @returns Whether error is an instance of FSM Response Error */
    static isFsmError(error) { return (typeof error === 'object' && error instanceof FsmResponseError); }
    /** Extracts data from FSM Response Error
     * @param {FsmResponseError} error The FSM Response Error
     * @returns {object|undefined} The extracted data */
    static pluckErrorData(error) { return FsmAjax.isFsmError(error) ? error.response.data : undefined; }
}
/** Composable method for UseCase Higher Order Components (UCHOC)
 * @param {object} config The UseCase config object
 * @param {Array<object>} views An array of MegaSet-Views' objects 
 * @param {function} onInitialized An Initialization callback method
 * @param {function} onError An Error callback method
 * @returns Returns `activateView`, `close` and `render` methods */
function useUseCaseViewManager(config, views, onInitialized, onError, initView = '') {
    if (!isObject(config) || isNilOrEmpty(config.fsmUrl)) { throw new Error('Invalid UseCase Config Object'); }
    if (!Array.isArray(views) || views.length === 0) { throw new Error('Invalid UseCase Views Array'); }
    if ( typeof onInitialized !== 'function') { throw new Error('Invalid UseCase onInitialized Callback Function'); }
    if ( typeof onError !== 'function') { throw new Error('Invalid UseCase onError Callback Function'); }
    const usecase = getCurrentInstance(); // Instance of UseCase HOC
    if (!!!usecase) { throw new Error('Unable to get UseCase Instance'); }    
    // Template Refs
    const $refs = ref({});
    // UseCase Views Collection
    const ucViews = views.reduce(function(collection, view) {
        // Validate View Definition
        if (!isObject(view) || // View must be defined as an Object
            isNilOrEmpty(view.name) || // View must have valid name
            isNilOrEmpty(toValue(view.title)) || // View must have valid title
            (view.component === undefined && view.components === undefined) || // At least one should be defined
            (view.components === undefined && !isObject(view.component)) ||
            (view.component === undefined && !Array.isArray(view.components)) || 
            (isObject(view.component) && (view.components !== undefined ||
                !isObject(view.props) || (!isNil(view.handlers) && !isObject(view.handlers))
            )) ||
            (Array.isArray(view.components) && (view.component !== undefined ||
                    view.components.length === 0 ||
                    view.components.some(x => isNilOrEmpty(x.ref)) ||
                    view.components.some(x => !isObject(x.props)) ||
                    view.components.some(x => !isNil(x.handlers) && !isObject(x.handlers))
            ))
        ) { throw new Error('Invalid UseCase View definition'); }        
        // Uniqueness Check
        if (collection.has(view.name)) { throw new Error(`UseCase view with spcified name "${view.name}" already exists`); }
        
        if (isObject(view.component)) {            
            // Define Template Ref
            view.props.ref = defineTemplateRef(view);
            // Add view definition to collection        
            collection.set(view.name, { 
                name: view.name,
                $ref: ref(null),
                title: view.title, 
                component: shallowRef(view.component), 
                props: view.props, 
                handlers: view.handlers || {} 
            });
        } else if(Array.isArray(view.components)) {            
            const components = view.components.map(function(child){
                child.props.ref = defineChildTemplateRef(view, child);
                return {
                    component: shallowRef(child.component), 
                    props: child.props, 
                    handlers: child.handlers || {}
                };
            });
            // Add view definition to collection        
            collection.set(view.name, { 
                name: view.name,
                title: view.title, 
                $refs: {},                
                components
            });
        } else { throw new Error('Invalid UseCase View Type'); }        
        return collection;
    }, new Map());
    function defineTemplateRef(viewDef) {
        const setRef = function(node) {
            const view = ucViews.get(viewDef.name);
            view.$ref.value = node;
            $refs.value[`ref${viewDef.name}`] = node;
        }
        return setRef;
    }
    function defineChildTemplateRef(viewDef, childDef) {
        const setRef = function(node) {
            const view = ucViews.get(viewDef.name);
            view.$refs[childDef.ref] = node;
            $refs.value[childDef.ref] = node;
        }
        return setRef;
    }
    // Add-Ons: Vuex Store, Router and Route
    const vuexStore = useStore(), router = useRouter(), route = useRoute();
    // FSM AJAX api
    const fsm = new FsmAjax(config);
    // Loader View (definition)
    const loaderView = { title: '', component: Loader, props: {}, handlers: {} };
    // Active View
    const theActiveView = ref(ucViews.has(initView ?? '') ? ucViews.get(initView) : loaderView);
    /** Activates specified MegaSetg View
     * @param {string} view The MegaSet view name */
    function activateView(view) {
        if (!ucViews.has(view)) { throw new Error(`View to activate "${view}" does not exist`); }
        theActiveView.value = ucViews.get(view);
        if (usecase.props.modal === true) { usecase.emit('update:title', theActiveView.value.title); } 
        else if (isRef(route.meta.title)) { route.meta.title.value = theActiveView.value.title; }            
    }
    // Dispose Flag
    const disposing = ref(false);
    const killFsmOnClose = ref(false);
    function routeLeaving(to, from, next) {
        killFsmOnClose.value = toValue(from?.meta?.killFsmOnClose ?? false);
        next();
    }
    // Dispose Method
    async function dispose() {
        if (vuexStore.getters.getURL === config.fsmUrl) { 
            vuexStore.dispatch("fsmURL", null);
            vuexStore.dispatch("activityCode", '');
            vuexStore.dispatch("subActivityCode", '');
        }
        if (disposing.value === true) { return; }
        try {
            disposing.value = true;
            if (killFsmOnClose.value === true || usecase.props.modal === true) {
                await fsm.postKill();
            }            
        } catch(error) { onError(error, 'Dispose'); }
    }
    /** Closes UseCase HOC
     * @param {boolean} kill Whether to post FSM `KILL` transition on disposal */
    function close(kill = true) {        
        if (kill === false && disposing.value === false) { disposing.value = true; }
        if (usecase.props.modal === true) { usecase.emit('closing'); } else { router.go(-1); }
    }
    // Initialize Usecase
    async function initialize() {
        // Flag to tolerate FSM Errors
        const tolerate = (typeof config.tolerateInit === 'boolean') ? config.tolerateInit : false;
        try {
            if (fsm.batchRequired && typeof FsmAjax.header.loginUserBatch !== 'number') {
                throw new Error('Batch is not Open, Open a Batch');
            }
            if (usecase.props.modal === true) { usecase.emit('update:title', theActiveView.value.title); } 
            else {
                vuexStore.dispatch("fsmURL", config.fsmUrl); 
                if (isRef(route.meta.title)) { route.meta.title.value = theActiveView.value.title; }
            }
            const data = await fsm.postInit();
            onInitialized(data);
        } catch(error) { 
            disposing.value = true;
            onError(error, 'Initialize');
            if (!FsmAjax.isFsmError(error) || !tolerate) { close(); }
        }
    }
    // Reinitialize UseCase    
    async function reinitialize() {
        try { await fsm.postKill(); } catch(error) { onError(error, 'Kill'); return; }
        initialize();
    }
    // UseCase Render Function
    function render(_ctx, _cache) {
        if (Array.isArray(theActiveView.value.components)) {
            return h(Fragment, null, theActiveView.value.components.map(function(item){
                return h(resolveDynamicComponent(item.component), mergeProps(item.props, toHandlers(item.handlers)));
            }));
        } else {
            return h(resolveDynamicComponent(theActiveView.value.component), mergeProps(theActiveView.value.props, toHandlers(theActiveView.value.handlers)));
        }
    }
    // Life Cycle Hooks    
    onBeforeMount(initialize);
    onBeforeUnmount(dispose);
    onBeforeRouteLeave(routeLeaving);
    // The Active View
    const activeView = computed(function() {
        if (!!theActiveView.value && !!theActiveView.value.name) {
            return { name: theActiveView.value.name, $ref: theActiveView.value.$ref }
        } else { return undefined; }
    });
    // Return Methods
    return { activateView, close, render, reinitialize, activeView, $refs: computed(() => $refs.value) };
}
/** Defines UseCase HOC
 * @param {string} name UseCase HOC name
 * @param {function} setup UseCase HOC setup method
 * @returns UseCase HOC */
function defineUseCaseComponent(name, setup) {
    if (isNilOrEmpty(name) || typeof setup !== 'function') { throw new Error('Invalid UseCase Component definition'); }
    return defineComponent(setup, {
        name,
        props: {
            fsmUrl: { type: String, required: true },            
            modal: { type: Boolean, default: false },
            title: { type: String, default: '' }
        },
        emits: ['update:title', 'closing']
    });
}
/** Defines UseCase Loader function
 * @param {string} name UseCase HOC name
 * @param {function} setup UseCase HOC setup method
 * @returns {function} UseCase Loader Function */
function defineUseCaseLoader(name, setup) {    
    function loader(ctx, fsmUrl) {
        const router = ctx.$router;
        if (router.hasRoute(name)) { router.removeRoute(name); }
        router.addRoute({
            path: `/${name}`,
            name,
            component: defineUseCaseComponent(name, setup),
            props: { fsmUrl },
            meta: { title: ref(''), killFsmOnClose: ref(true), hideSideNavMenu: true }
        });
        router.push({name});        
    }
    return loader;
}
export { FsmAjax, useUseCaseViewManager, defineUseCaseComponent, defineUseCaseLoader };