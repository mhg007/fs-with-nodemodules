import { ElMessageBox } from 'element-plus';
import moment from 'moment';
const alertDefaults = {
    draggable: true,
    showClose: false,
    autofocus: true,
    closeOnClickModal: false,
    closeOnPressEscape: false,
    dangerouslyUseHTMLString: true,
};
const confirmDefaults = {
    center: true,
    draggable: true,
    showClose: false,
    autofocus: true,
    closeOnPressEscape: false,
    closeOnClickModal: false,
    cancelButtonClass: "btn-custom-cancel",
    dangerouslyUseHTMLString: true,
};
const plz = (num, size) => String(num).padStart(size, '0');
/** Checks whether specified `val` is an empty or nil (`null` | `undefined`) string
 * @param {*} val The value to check
 * @returns {boolean} Whether specified `val` is an empty or nil (`null` | `undefined`) string */
const isNOES = (val) => !(typeof val === 'string' && val !== '');
const helper = {
    /** Checks whether specified `val` is an empty or nil (`null` | `undefined`) string
    * @param {string} val The value to check
    * @returns {boolean} Whether specified `val` is an empty or nil (`null` | `undefined`) string */
    isNilOrEmpty: isNOES,
    /** Focuses specified element
     * @param {string | Object} target The **`id`** of the target element as a **`string`** or 
     * the element itself as an **`object`** having **`focus()`** method */
    focus(target) {
        if (typeof target === 'string' && target !== '' && document && document.getElementById) { target = document.getElementById(target); }
        if (typeof target === 'object' && typeof target.focus === 'function') { target.focus(); }
    },
    /** Opens Alert Message Box
     * @param {string|object} message The message to display
     * @param {string} title The title of Message Box
     * @returns {Promise} Returns **`Promise`** object for further processing */
    alert(message, title = 'Message') { 
        const msg = (typeof message === 'string' ? message : (typeof message === 'object' && typeof message.message === 'string' ? message.message : undefined)) ?? '';
        return ElMessageBox.alert(msg, title ?? 'Message', alertDefaults); 
    },
    /** Opens Confirm Message Box 
     * @param {String} message The message to display
     * @param {*} title The title of Message Box
     * @param {*} option The option of confirm Message Box
     * @returns {Promise} Returns **`Promise`** object for further processing */
    confirm(message, title, option) {        
        const currentOptions = Object.assign(option, confirmDefaults)
        return ElMessageBox.confirm(message, title ?? 'Message', currentOptions);
    },
    /** Pads leading zeros 
     * @param {Number} num The value to be padded
     * @param {Number} size The max length of ouput string after padding
     * @returns {String} The padded string */
    padLeadingZeros: plz,
    date: {
        /** Converts **Database (DB)** date format **`'YYYY-MM-DD'`** into **Front-end (FE)** date format **`'DD/MM/YYYY'`**
         * @param {String} date The date in **Database (DB)** format **`'YYYY-MM-DD'`**
         * @returns {String} Returns date in **Front-end (FE)** format **`'DD/MM/YYYY'`** */
        dbToFe(date) { return !helper.isNilOrEmpty(date) ? moment(date).format('DD/MM/YYYY') : undefined; },
        /** Converts **Front-end (FE)** date format **`'DD/MM/YYYY'`** into **Database (DB)** date format **`'YYYY-MM-DD'`**
         * @param {String} date The date in  **Front-end (FE)** format **`'DD/MM/YYYY'`**
         * @returns {String} Returns date in **Database (DB)** format **`'YYYY-MM-DD'`** */
        feToDb(date) { return !helper.isNilOrEmpty(date) ? moment(date, 'DD/MM/YYYY').format('YYYY-MM-DD') : undefined; }
    },    
    acctNum: {
        /** Concatenates Account Number fragments with dashes
         * @param {Number|String} branch The branch number
         * @param {Number|String} type The account type number
         * @param {Number|String} cust The Customer number
         * @param {Number|String} run The run digits
         * @param {Number|String} digit The checksum digit
         * @returns Returns Account Number concatenated with dashes */
        hyphenateBTCRD(branch, type, cust, run, digit) { return [plz(branch, 4), plz(type, 4), plz(cust, 6), plz(run, 2), digit].join('-'); },
        /** Concatenates Account Number fragments
         * @param {Number|String} branch The branch number
         * @param {Number|String} type The account type number
         * @param {Number|String} cust The Customer number
         * @param {Number|String} run The run digits
         * @param {Number|String} digit The checksum digit
         * @returns Returns concatenated Account Number */
        concatBTCRD(branch, type, cust, run, digit) { return [plz(branch, 4), plz(type, 4), plz(cust, 6), plz(run, 2), digit].join(''); },
        /** Concatenates Account Number fragments         
         * @param {Number|String} type The account type number
         * @param {Number|String} cust The Customer number
         * @param {Number|String} run The run digits
         * @param {Number|String} digit The checksum digit
         * @returns Returns concatenated Account Number */
        concatTCRD(type, cust, run, digit) { return [plz(type, 4), plz(cust, 6), plz(run, 2), digit].join(''); },
        /** Concatenates Account Number fragments with dashes         
         * @param {Number|String} type The account type number
         * @param {Number|String} cust The Customer number
         * @param {Number|String} run The run digits
         * @param {Number|String} digit The checksum digit
         * @returns Returns Account Number concatenated with dashes */
        hyphenateTCRD(type, cust, run, digit) { return [plz(type, 4), plz(cust, 6), plz(run, 2), digit].join('-'); }
    }
};
export default helper;
